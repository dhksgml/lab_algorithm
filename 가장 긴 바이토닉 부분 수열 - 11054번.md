# 가장 긴 바이토닉 부분 수열 - 11054번

- 문제

## 문제

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, **30**, 25, 20}과 {10, 20, 30, **40**}, {**50**, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

## 출력

첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 예제 입력 1 복사

```
10
1 5 2 1 4 3 4 5 2 1

```

## 예제 출력 1 복사

```
7
```

- 전체코드

```c++
#include <iostream>
using namespace std;


int main()
{
	int N;
	int* A;
	int* l_dp;
	int* r_dp;
	int max = 0;

	cin >> N;
	A = new int[N];
	l_dp = new int[N];
	r_dp = new int[N];

	for (int i = 0; i < N; i++)
	{
		l_dp[i] = 0;
		r_dp[i] = 0;
	}

	for (int i = 0; i < N; i++)
	{
		cin >> A[i];
	}

	for (int i = 0; i < N; i++)
	{
		l_dp[i] = 1;
		for (int j = 0; j < i; j++)
		{
			if (A[j] < A[i] && l_dp[i] < l_dp[j] + 1) {
				l_dp[i] = l_dp[j] + 1;
			}
		}
	}

	for (int i = N - 1; i >= 0; i--)
	{
		r_dp[i] = 1;
		for (int j = N - 1; j > i; j--)
		{
			if (A[j] < A[i] && r_dp[i] < r_dp[j] + 1) {
				r_dp[i] = r_dp[j] + 1;
			}
		}
	}

	for (int i = 0; i < N; i++)
	{
		l_dp[i] = l_dp[i] + r_dp[i] - 1;
		if (l_dp[i] > max)
			max = l_dp[i];
	}

	/*for (int i = 0; i < N; i++)
		cout << l_dp[i] << " ";*/

	cout << max;
}
```

- 느낀 점

일단 바이토닉 부분 수열이라는 것을 새로 알게 되었다.

문제에서 찾으라는 바이토닉 부분 수열은 {1 4 3 5} 이렇게 수열이 주어지면, {1, 4, 5}나 {1, 3, 5} 처럼 값을 찾을 수 있는 거였다. 처음에는 {1 4}, {4 3} 이렇게 꼭 붙어있어야 길이를 세는 건 줄 알았다...

바이토닉 부분 수열에 유형에는 크게 3가지가 있는데

1. 어떤 특정 값을 기준으로 양쪽이 감소하거나, 
2. 오른쪽을 기준으로 값이 감소하거나, 
3. 왼쪽을 기준으로 값이 감소해야 했다.

결국 가장 긴 바이토닉 수열의 길이를 구하기 위해서,  위에서 언급한 2번과 3번, 즉 왼쪽으로 길이를 쟀을 때 가장 긴 길이 + 오른쪽에서 길이를 쟀을 때 가장 긴 길이 = 1번 유형의 길이가 되어 가장 길게 된다. 단, 왼쪽과 오른쪽의 부분수열 길이를 쟀을 때 중간에 있는 값이 1번 중복되므로 길이에서 1을 빼준다.

왼쪽과 오른쪽에서 부분수열 길이를 셀 때, 이중 for문을 통해 배열 내 현재 위치까지 검사를 할 수 있었다. 

다음 두가지 조건을 사용하여 만족할 경우 dp값에 +1을 했다.

1. 주어진 부분 수열 요소를 비교하여 현재 i 위치 값이 j 위치 값보다 클 경우
2. 저장한 dp[i] 값이 dp[j] + 1보다 작을 때